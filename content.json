{"meta":{"title":"Abean的博客","subtitle":"一个只会切图的靓仔罢了","description":"","author":"veonbean","url":"http://example.com","root":"/"},"pages":[{"title":"设计模式概述","date":"2020-12-09T08:01:22.000Z","updated":"2020-12-09T09:36:39.248Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"什么是设计模式 设计模式（Design Pattern），是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可拓展性和可维护性。 为什么使用设计模式？ 软件开发要实现可维护、可拓展，就必须尽可能复用代码，并且降低代码耦合度。 设计模式必须遵循的几个原则： 开闭原则 软件应该对拓展开放，对修改关闭。即更新功能时，能不该代码就尽量不改，如果只新增代码就完成了新功能，那是最好的。 里氏替换原则 如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。 设计模式分为以下几种类型： 创建型模式 工厂方法 抽象方法 生成器 原型 单例 结构型模式 适配器 桥接 组合 装饰器 外观 享元 代理 行为型模式 责任链 命令 解释器 迭代器 中介 备忘录 观察者 状态 策略 模版方法 访问者"},{"title":"","date":"2021-05-06T07:52:26.981Z","updated":"2021-05-06T07:52:26.981Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个只会切图的靓仔罢了"},{"title":"categories","date":"2020-12-09T08:52:48.000Z","updated":"2020-12-09T08:53:34.372Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式-模板方法","slug":"设计模式-模板方法","date":"2020-12-22T08:45:35.000Z","updated":"2020-12-22T08:45:35.179Z","comments":true,"path":"2020/12/22/设计模式-模板方法/","link":"","permalink":"http://example.com/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"设计模式-组合","slug":"设计模式-组合","date":"2020-12-22T08:45:11.000Z","updated":"2020-12-22T08:45:11.180Z","comments":true,"path":"2020/12/22/设计模式-组合/","link":"","permalink":"http://example.com/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"设计模式-命令","slug":"设计模式-命令","date":"2020-12-22T08:44:59.000Z","updated":"2020-12-23T06:52:23.256Z","comments":true,"path":"2020/12/22/设计模式-命令/","link":"","permalink":"http://example.com/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4/","excerpt":"","text":"将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求进行排队或记录请求日志，以及支持可撤销的操作。 命令模式是指，将请求封装成一个命令，然后执行该命令。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-发布订阅","slug":"设计模式-发布订阅","date":"2020-12-22T08:44:13.000Z","updated":"2020-12-22T10:12:48.448Z","comments":true,"path":"2020/12/22/设计模式-发布订阅/","link":"","permalink":"http://example.com/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","excerpt":"","text":"定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 观察者模式又称发布-订阅模式。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。 优缺点 优点时间上、对象上解耦 缺点创建订阅者需要一定的时间和内存，订阅的消息未必发生，但观察者始终存在 举个栗子电商网站假设一个电商网站，有多种商品（Product），消费者（Customer）和管理员（Admin）对商品上架和价格改变都感兴趣，希望可以得到第一时间的通知，商场可以这么写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 商场function Store() &#123; // 产品列表 this.product = &#123;&#125;; // 观察者列表 this.observers = [];&#125;// 消费者function Customer(name) &#123; this.name = name;&#125;// 管理员function Admin(name) &#123; this.name = name;&#125;// 添加新商品Store.prototype.addNewProduct = function(name, price) &#123; this.product[name] = price; // 通知观察者 this.observers.forEach(item =&gt; item.observer.onPublish(&#123;name, price&#125;));&#125;;// 修改商品价格Store.prototype.setProductPrice = function(name, price) &#123; this.product[name] = price; // 通知观察者 this.observers.forEach(item =&gt; item.observer.onPriceChange(&#123;name, price&#125;));&#125;;// 注册观察者Store.prototype.addObserver = function(name, observer) &#123; this.observers.push(&#123; name, observer, &#125;);&#125;;// 移除观察者Store.prototype.removeObserver = function(name) &#123; this.observers = this.observers.filter(item =&gt; item.name !== name);&#125;;// 收到通知后触发事件Customer.prototype.onPublish = function(product) &#123; console.log(`顾客$&#123;this.name&#125;，有新商品$&#123;product.name&#125;上架，价格为$&#123;product.price&#125;`);&#125;;Customer.prototype.onPriceChange = function(product) &#123; console.log(`顾客$&#123;this.name&#125;，商品$&#123;product.name&#125;价格变更为$&#123;product.price&#125;`);&#125;;Admin.prototype.onPublish = function(product) &#123; console.log(`管理员$&#123;this.name&#125;，有新商品$&#123;product.name&#125;上架，价格为$&#123;product.price&#125;`);&#125;;Admin.prototype.onPriceChange = function(product) &#123; console.log(`管理员$&#123;this.name&#125;，商品$&#123;product.name&#125;价格变更为$&#123;product.price&#125;`);&#125;;const store = new Store();const customer = new Customer(&#x27;张三&#x27;);const admin = new Admin(&#x27;李四&#x27;);store.addObserver(&#x27;customer&#x27;, customer);store.addObserver(&#x27;admin&#x27;, admin);store.addNewProduct(&#x27;商品1&#x27;, 1000);store.addNewProduct(&#x27;商品2&#x27;, 2000);store.setProductPrice(&#x27;商品1&#x27;, 1500);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"手写Promise","slug":"手写Promise","date":"2020-12-14T08:10:43.000Z","updated":"2020-12-14T08:17:05.615Z","comments":true,"path":"2020/12/14/手写Promise/","link":"","permalink":"http://example.com/2020/12/14/%E6%89%8B%E5%86%99Promise/","excerpt":"","text":"Promise对象用于表示一个异步操作的最终完成（或失败）及其结果值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"JavaScript标准内置对象","slug":"JavaScript/JavaScript标准内置对象","permalink":"http://example.com/categories/JavaScript/JavaScript%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://example.com/tags/Promise/"}]},{"title":"设计模式-迭代器","slug":"设计模式-迭代器","date":"2020-12-14T02:45:40.000Z","updated":"2020-12-14T08:05:20.519Z","comments":true,"path":"2020/12/14/设计模式-迭代器/","link":"","permalink":"http://example.com/2020/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即迭代器模式使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 JavaScript内置了迭代器，如forEach、map等。 分类 内部迭代器 内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。 12345678const each = function(arr, cb) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; cb(i, arr[i]); &#125;&#125;;each([1, 2, 3], (index, item) =&gt; &#123; console.log(index, item);&#125;); 优点调用方便，不用关心内部实现，仅在初始调用时做交互。 缺点内部迭代规则以被提前规定，不利于拓展。 外部迭代器 外部迭代器必须显式地请求迭代下一个元素。 1234567891011121314151617181920212223242526272829303132333435function Iterator(obj) &#123; let current = 0; const next = () =&gt; &#123; current++; &#125;; const isDone = () =&gt; &#123; return current &gt;= obj.length; &#125;; const getItem = () =&gt; &#123; return obj[current]; &#125;; return &#123; next, isDone, getItem, &#125;;&#125;function compare(a, b) &#123; while(!a.isDone() &amp;&amp; !b.isDone()) &#123; if (a.getItem() !== b.getItem()) &#123; throw new Error(&#x27;a与b不相等&#x27;); &#125; a.next(); b.next(); &#125; console.log(&#x27;a与b相等&#x27;);&#125;const iterator1 = Iterator([1, 2, 3]);const iterator2 = Iterator([1, 2, 3]);compare(iterator1, iterator2); ES6实现1234567891011121314151617181920212223242526272829303132class Iterator &#123; constructor(container) &#123; this.list = container.list; this.index = 0; &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++]; &#125; return null; &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false; &#125; return true; &#125;&#125;class Container &#123; constructor(list) &#123; this.list = list; &#125; getTterator() &#123; return new Iterator(this); &#125;&#125;const container = new Container([1, 2, 3, 4]);const iterator = container.getIterator();while(iterator.hasNext()) &#123; console.log(iterator.next());&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-代理","slug":"设计模式-代理","date":"2020-12-10T02:28:39.000Z","updated":"2020-12-14T07:44:39.650Z","comments":true,"path":"2020/12/10/设计模式-代理/","link":"","permalink":"http://example.com/2020/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/","excerpt":"","text":"为其他对象提供一种代理以控制对这个对象的访问。 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 分类 保护代理 用代理对象控制对原始对象的访问，常用于鉴权。 虚拟代理 把一些开销很大的对象，延迟到真正需要它的时候才去创建。 举个栗子使用虚拟代理实现图片预加载 1234567891011121314151617181920212223const myImg = (function() &#123; const imgNode = document.createElement(&#x27;img&#x27;); document.body.appendChild(imgNode); return &#123; setSrc: (src) =&gt; &#123; imgNode.src = src; &#125;, &#125;;&#125;)();const proxyImage = (function() &#123; const img = new Image(); img.onload = () =&gt; &#123; myImg.setSrc(img.src); &#125;; return &#123; setSrc: src =&gt; &#123; img.src = src; myImage.setSrc(&#x27;&#x27;); &#125;, &#125;;&#125;)();proxyImage.setSrc(&#x27;&#x27;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-策略","slug":"设计模式-策略","date":"2020-12-10T02:28:26.000Z","updated":"2020-12-14T07:44:46.070Z","comments":true,"path":"2020/12/10/设计模式-策略/","link":"","permalink":"http://example.com/2020/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/","excerpt":"","text":"定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于它的客户而变化。 策略模式：strategy，是指，定义一组算法，并把其封装到一个对象中，然后在运行时，可以灵活的使用其中的一个算法。策略模式的目的就是把算法的使用和算法的实现分离开来。 一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类，策略类封装饿了具体的算法，并负责具体的计算过程。第二部分是环境类context，context接受客户的请求，随后把请求委托给某一个策略类。要实现这一点，说明context中要维持对策略类的引用。 举个栗子 计算奖金123456789101112const strategies = &#123; S: salary =&gt; salary * 4, A: salary =&gt; salary * 3, B: salary =&gt; salary * 2,&#125;;const calculateBonus = (level, salary) =&gt; &#123; return strategies[level](salary);&#125;;console.log(calculateBonus(&#x27;S&#x27;, 10000)); // 40000console.log(calculateBonus(&#x27;A&#x27;, 10000)); // 30000 优缺点 优点 利用组合、委托和多态等技术和思想，可以有效避免多重条件选择语句。 提供了开放-封闭原则的完美支持，将算法封装在独立的strategy中，使它们易于切换、理解和拓展。 可复用 缺点 要使用策略模式，必须了解所有的strategy，了解各个strategy之间的不同点，这样才能选择一个合适的strategy。 会增加策略类或者策略对象。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式-单例","slug":"设计模式-单例","date":"2020-12-09T09:53:39.000Z","updated":"2020-12-14T07:44:32.418Z","comments":true,"path":"2020/12/09/设计模式-单例/","link":"","permalink":"http://example.com/2020/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/","excerpt":"","text":"保证一个类只有一个实例，并提供一个访问它的全局访问点。如线程池、window对象、全局缓存等只需要一个实例的对象。 实现单例模式使用一个变量来标识是否已经为当前类创建过实例，在获取该类实例的时候进行判断，若是则返回缓存的实例，否则创建一个新的实例并返回。 使用全局变量 1234567891011121314var instance = null;function getInstance(arg) &#123; if (!instance) &#123; instance = arg; &#125; return instance;&#125;const a = getInstance(&#x27;a&#x27;);const b = getInstance(&#x27;b&#x27;);a === b;// true 缺点：必须不利于代码复用。 使用闭包 12345678910111213141516171819function Singleton(name) &#123; this.name = name;&#125;SingleTon.getInstance = (function () &#123; var instance = null; return function(name) &#123; if (!instance) &#123; instance = new Singleton(name); &#125; return instance; &#125;&#125;)();const a = Singleton.getInstance(&#x27;a&#x27;);const b = Singleton.getInstance(&#x27;b&#x27;);a === b;// true 使用函数 1234567891011121314function Singleton(name) &#123; this.name = name; this.instance = null;&#125;Singleton.getInstance = function(name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;;const a = Singleton.getInstance(&#x27;a&#x27;);const b = Singleton.getInstance(&#x27;b&#x27;);a === b;// true 缺点：必须使用getInstance获取实例，而不是使用new 使用class 12345678910111213141516171819class Singleton &#123; constructor(props) &#123; const &#123; name, ...other &#125; = props; this.name = name; this.instance = null; &#125; setName = (name) =&gt; &#123; return this.name = name; &#125; static getInstance = (name) =&gt; &#123; this.instance = this.instance ? this.instance : new Singleton(name); &#125;&#125;const a = Singleton.getInstance(&#x27;a&#x27;);const b = Singleton.getInstance(&#x27;b&#x27;);a === b;// true 类通过static定义的方法，不能在实例中调用，应该通过类本身进行调用。 1234567891011121314class Singleton &#123; constructor(name) &#123; if (typeof Singleton.instance === &#x27;object&#x27;) &#123; return Singleton.instance; &#125; Singleton.instance = this; this.name = name; return this; &#125;&#125;const a = new Singleton(&#x27;a&#x27;);const b = new Singleton(&#x27;b&#x27;);a === b;// true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式概述","slug":"设计模式概述","date":"2020-12-09T08:01:22.000Z","updated":"2020-12-22T08:56:57.957Z","comments":true,"path":"2020/12/09/设计模式概述/","link":"","permalink":"http://example.com/2020/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"什么是设计模式 设计模式（Design Pattern），是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可拓展性和可维护性。为什么使用设计模式？软件开发要实现可维护、可拓展，就必须尽可能复用代码，并且降低代码耦合度。 设计模式必须遵循的几个原则： 开闭原则 软件应该对拓展开放，对修改关闭。即更新功能时，能不该代码就尽量不改，如果只新增代码就完成了新功能，那是最好的。 里氏替换原则 如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。 设计模式分为以下几种类型： 创建型模式 工厂方法 抽象方法 生成器 原型 设计模式-单例 结构型模式 适配器 桥接 设计模式-组合 装饰器 外观 享元 设计模式-代理 行为型模式 责任链 设计模式-命令 解释器 设计模式-迭代器 中介 备忘录 设计模式-发布订阅 状态 设计模式-策略 设计模式-模板方法 访问者","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","permalink":"http://example.com/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript标准内置对象","slug":"JavaScript/JavaScript标准内置对象","permalink":"http://example.com/categories/JavaScript/JavaScript%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Promise","slug":"Promise","permalink":"http://example.com/tags/Promise/"}]}