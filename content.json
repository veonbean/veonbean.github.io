{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"设计模式概述","text":"什么是设计模式 设计模式（Design Pattern），是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可拓展性和可维护性。 为什么使用设计模式？ 软件开发要实现可维护、可拓展，就必须尽可能复用代码，并且降低代码耦合度。 设计模式必须遵循的几个原则： 开闭原则 软件应该对拓展开放，对修改关闭。即更新功能时，能不该代码就尽量不改，如果只新增代码就完成了新功能，那是最好的。 里氏替换原则 如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。 设计模式分为以下几种类型： 创建型模式 工厂方法 抽象方法 生成器 原型 单例 结构型模式 适配器 桥接 组合 装饰器 外观 享元 代理 行为型模式 责任链 命令 解释器 迭代器 中介 备忘录 观察者 状态 策略 模版方法 访问者","link":"/tags/index.html"},{"title":"","text":"一个只会切图的靓仔罢了","link":"/about/index.html"}],"posts":[{"title":"手写Promise","text":"Promise对象用于表示一个异步操作的最终完成（或失败）及其结果值。","link":"/2020/12/14/%E6%89%8B%E5%86%99Promise/"},{"title":"设计模式-代理","text":"为其他对象提供一种代理以控制对这个对象的访问。 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 分类 保护代理 用代理对象控制对原始对象的访问，常用于鉴权。 虚拟代理 把一些开销很大的对象，延迟到真正需要它的时候才去创建。 举个栗子使用虚拟代理实现图片预加载 1234567891011121314151617181920212223const myImg = (function() { const imgNode = document.createElement('img'); document.body.appendChild(imgNode); return { setSrc: (src) =&gt; { imgNode.src = src; }, };})();const proxyImage = (function() { const img = new Image(); img.onload = () =&gt; { myImg.setSrc(img.src); }; return { setSrc: src =&gt; { img.src = src; myImage.setSrc(''); }, };})();proxyImage.setSrc('');","link":"/2020/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/"},{"title":"设计模式-单例","text":"保证一个类只有一个实例，并提供一个访问它的全局访问点。如线程池、window对象、全局缓存等只需要一个实例的对象。 实现单例模式使用一个变量来标识是否已经为当前类创建过实例，在获取该类实例的时候进行判断，若是则返回缓存的实例，否则创建一个新的实例并返回。 使用全局变量 1234567891011121314var instance = null;function getInstance(arg) { if (!instance) { instance = arg; } return instance;}const a = getInstance('a');const b = getInstance('b');a === b;// true 缺点：必须不利于代码复用。 使用闭包 12345678910111213141516171819function Singleton(name) { this.name = name;}SingleTon.getInstance = (function () { var instance = null; return function(name) { if (!instance) { instance = new Singleton(name); } return instance; }})();const a = Singleton.getInstance('a');const b = Singleton.getInstance('b');a === b;// true 使用函数 1234567891011121314function Singleton(name) { this.name = name; this.instance = null;}Singleton.getInstance = function(name) { if (!this.instance) { this.instance = new Singleton(name); } return this.instance;};const a = Singleton.getInstance('a');const b = Singleton.getInstance('b');a === b;// true 缺点：必须使用getInstance获取实例，而不是使用new 使用class 12345678910111213141516171819class Singleton { constructor(props) { const { name, ...other } = props; this.name = name; this.instance = null; } setName = (name) =&gt; { return this.name = name; } static getInstance = (name) =&gt; { this.instance = this.instance ? this.instance : new Singleton(name); }}const a = Singleton.getInstance('a');const b = Singleton.getInstance('b');a === b;// true 类通过static定义的方法，不能在实例中调用，应该通过类本身进行调用。 1234567891011121314class Singleton { constructor(name) { if (typeof Singleton.instance === 'object') { return Singleton.instance; } Singleton.instance = this; this.name = name; return this; }}const a = new Singleton('a');const b = new Singleton('b');a === b;// true","link":"/2020/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"},{"title":"设计模式-发布订阅","text":"定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 观察者模式又称发布-订阅模式。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。 优缺点 优点时间上、对象上解耦 缺点创建订阅者需要一定的时间和内存，订阅的消息未必发生，但观察者始终存在 举个栗子电商网站假设一个电商网站，有多种商品（Product），消费者（Customer）和管理员（Admin）对商品上架和价格改变都感兴趣，希望可以得到第一时间的通知，商场可以这么写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 商场function Store() { // 产品列表 this.product = {}; // 观察者列表 this.observers = [];}// 消费者function Customer(name) { this.name = name;}// 管理员function Admin(name) { this.name = name;}// 添加新商品Store.prototype.addNewProduct = function(name, price) { this.product[name] = price; // 通知观察者 this.observers.forEach(item =&gt; item.observer.onPublish({name, price}));};// 修改商品价格Store.prototype.setProductPrice = function(name, price) { this.product[name] = price; // 通知观察者 this.observers.forEach(item =&gt; item.observer.onPriceChange({name, price}));};// 注册观察者Store.prototype.addObserver = function(name, observer) { this.observers.push({ name, observer, });};// 移除观察者Store.prototype.removeObserver = function(name) { this.observers = this.observers.filter(item =&gt; item.name !== name);};// 收到通知后触发事件Customer.prototype.onPublish = function(product) { console.log(`顾客${this.name}，有新商品${product.name}上架，价格为${product.price}`);};Customer.prototype.onPriceChange = function(product) { console.log(`顾客${this.name}，商品${product.name}价格变更为${product.price}`);};Admin.prototype.onPublish = function(product) { console.log(`管理员${this.name}，有新商品${product.name}上架，价格为${product.price}`);};Admin.prototype.onPriceChange = function(product) { console.log(`管理员${this.name}，商品${product.name}价格变更为${product.price}`);};const store = new Store();const customer = new Customer('张三');const admin = new Admin('李四');store.addObserver('customer', customer);store.addObserver('admin', admin);store.addNewProduct('商品1', 1000);store.addNewProduct('商品2', 2000);store.setProductPrice('商品1', 1500);","link":"/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"},{"title":"设计模式-模板方法","text":"","link":"/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"title":"设计模式-命令","text":"将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求进行排队或记录请求日志，以及支持可撤销的操作。 命令模式是指，将请求封装成一个命令，然后执行该命令。","link":"/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4/"},{"title":"设计模式-策略","text":"定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于它的客户而变化。 策略模式：strategy，是指，定义一组算法，并把其封装到一个对象中，然后在运行时，可以灵活的使用其中的一个算法。策略模式的目的就是把算法的使用和算法的实现分离开来。 一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类，策略类封装饿了具体的算法，并负责具体的计算过程。第二部分是环境类context，context接受客户的请求，随后把请求委托给某一个策略类。要实现这一点，说明context中要维持对策略类的引用。 举个栗子 计算奖金123456789101112const strategies = { S: salary =&gt; salary * 4, A: salary =&gt; salary * 3, B: salary =&gt; salary * 2,};const calculateBonus = (level, salary) =&gt; { return strategies[level](salary);};console.log(calculateBonus('S', 10000)); // 40000console.log(calculateBonus('A', 10000)); // 30000 优缺点 优点 利用组合、委托和多态等技术和思想，可以有效避免多重条件选择语句。 提供了开放-封闭原则的完美支持，将算法封装在独立的strategy中，使它们易于切换、理解和拓展。 可复用 缺点 要使用策略模式，必须了解所有的strategy，了解各个strategy之间的不同点，这样才能选择一个合适的strategy。 会增加策略类或者策略对象。","link":"/2020/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/"},{"title":"设计模式-组合","text":"","link":"/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88/"},{"title":"设计模式-迭代器","text":"提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即迭代器模式使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 JavaScript内置了迭代器，如forEach、map等。 分类 内部迭代器 内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用。 12345678const each = function(arr, cb) { for (let i = 0; i &lt; arr.length; i++) { cb(i, arr[i]); }};each([1, 2, 3], (index, item) =&gt; { console.log(index, item);}); 优点调用方便，不用关心内部实现，仅在初始调用时做交互。 缺点内部迭代规则以被提前规定，不利于拓展。 外部迭代器 外部迭代器必须显式地请求迭代下一个元素。 1234567891011121314151617181920212223242526272829303132333435function Iterator(obj) { let current = 0; const next = () =&gt; { current++; }; const isDone = () =&gt; { return current &gt;= obj.length; }; const getItem = () =&gt; { return obj[current]; }; return { next, isDone, getItem, };}function compare(a, b) { while(!a.isDone() &amp;&amp; !b.isDone()) { if (a.getItem() !== b.getItem()) { throw new Error('a与b不相等'); } a.next(); b.next(); } console.log('a与b相等');}const iterator1 = Iterator([1, 2, 3]);const iterator2 = Iterator([1, 2, 3]);compare(iterator1, iterator2); ES6实现 1234567891011121314151617181920212223242526272829303132class Iterator { constructor(container) { this.list = container.list; this.index = 0; } next() { if (this.hasNext()) { return this.list[this.index++]; } return null; } hasNext() { if (this.index &gt;= this.list.length) { return false; } return true; }}class Container { constructor(list) { this.list = list; } getTterator() { return new Iterator(this); }}const container = new Container([1, 2, 3, 4]);const iterator = container.getIterator();while(iterator.hasNext()) { console.log(iterator.next());}","link":"/2020/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"title":"设计模式概述","text":"什么是设计模式 设计模式（Design Pattern），是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可拓展性和可维护性。为什么使用设计模式？软件开发要实现可维护、可拓展，就必须尽可能复用代码，并且降低代码耦合度。 设计模式必须遵循的几个原则： 开闭原则 软件应该对拓展开放，对修改关闭。即更新功能时，能不该代码就尽量不改，如果只新增代码就完成了新功能，那是最好的。 里氏替换原则 如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。 设计模式分为以下几种类型： 创建型模式 工厂方法 抽象方法 生成器 原型 设计模式-单例 结构型模式 适配器 桥接 设计模式-组合 装饰器 外观 享元 设计模式-代理 行为型模式 责任链 设计模式-命令 解释器 设计模式-迭代器 中介 备忘录 设计模式-发布订阅 状态 设计模式-策略 设计模式-模板方法 访问者","link":"/2020/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"}],"tags":[{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"设计模式","slug":"JavaScript/设计模式","link":"/categories/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript标准内置对象","slug":"JavaScript/JavaScript标准内置对象","link":"/categories/JavaScript/JavaScript%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"}]}